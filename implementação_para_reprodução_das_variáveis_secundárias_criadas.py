# -*- coding: utf-8 -*-
"""Implementação para Reprodução das Variáveis Secundárias Criadas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ptvt2FvTZqV9fTNzSaBUOWvJLVJBhKPV
"""

#Importação das bibliotecas
import pandas as pd
import numpy as np
from itertools import combinations


# Supondo que o DataFrame já está carregado como df


# 1. Seleção das variáveis numéricas (ignorando 'falha', 'RUL', 'udi')
features = [col for col in df.select_dtypes(include=[np.number]).columns if col not in ['falha', 'RUL', 'udi']]


# 2. FFT (Análise Frequencial) na 'velocidade de rotação'
def fft_features(series):
    """Calcula a frequência dominante e a energia do espectro para uma série temporal."""
    fft_vals = np.fft.fft(series)
    fft_abs = np.abs(fft_vals)
    freq_dom = np.argmax(fft_abs[1:]) + 1  # Frequência dominante (ignorando o termo DC)
    energy = np.sum(fft_abs ** 2)          # Energia total do espectro
    return freq_dom, energy


# Parâmetros da janela para FFT e agregações
window_size = 30
fft_freqs, fft_energies = [np.nan]*(window_size-1), [np.nan]*(window_size-1)  # Preencher início com NaN


# Aplica FFT em janelas deslizantes na variável 'velocidade de rotação'
for i in range(len(df) - window_size + 1):
    window = df['velocidade de rotação'].iloc[i:i+window_size]
    freq_dom, energy = fft_features(window)
    fft_freqs.append(freq_dom)
    fft_energies.append(energy)


df['velocidade_fft_freq_dom'] = fft_freqs
df['velocidade_fft_energy'] = fft_energies


# 3. Criação de lags (defasagens temporais)
for col in features:
    for lag in [1, 2, 3]:
        df[f'{col}_lag{lag}'] = df[col].shift(lag)


# 4. Cálculo de médias móveis, desvios padrões móveis e diferenças
mov_window = 10  # Tamanho da janela para médias/desvios móveis
for col in features:
    df[f'{col}_ma'] = df[col].rolling(mov_window).mean()
    df[f'{col}_std'] = df[col].rolling(mov_window).std()
    df[f'{col}_diff'] = df[col].diff()


# 5. Criação de interações entre variáveis (produtos, razões e diferenças)
for col1, col2 in combinations(features, 2):
    df[f'{col1}_x_{col2}'] = df[col1] * df[col2]
    df[f'{col1}_div_{col2}'] = df[col1] / (df[col2] + 1e-6)  # Adiciona pequeno valor para evitar divisão por zero
    df[f'{col1}_minus_{col2}'] = df[col1] - df[col2]


# 6. Agregações estatísticas por janela deslizante
for col in features:
    df[f'{col}_win_mean'] = df[col].rolling(window_size).mean()
    df[f'{col}_win_min'] = df[col].rolling(window_size).min()
    df[f'{col}_win_max'] = df[col].rolling(window_size).max()
    df[f'{col}_win_range'] = df[f'{col}_win_max'] - df[f'{col}_win_min']


# 7.Remover as primeiras linhas com NaN gerados pelas operações de janela
df = df.dropna().reset_index(drop=True)